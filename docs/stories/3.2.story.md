# Story 3.2: OAuth 2.0 Authentication Implementation

## Status
Ready for Development

## Story
**As a** user,
**I want** seamless OAuth 2.0 authentication with GoHighLevel,
**so that** API tools work without manual token management.

## Acceptance Criteria
1. OAuth 2.0 authorization flow implemented: authorization code exchange for access token
2. Client ID and Client Secret loaded from environment variables (GHL_CLIENT_ID, GHL_CLIENT_SECRET)
3. Access tokens auto-refresh before 24-hour expiry (with 5-minute safety buffer)
4. Tokens stored securely in encrypted local file using AES-256-CBC (not .env or git)
5. `test_oauth` MCP tool added to verify connection and refresh flow
6. OAuth errors logged with clear troubleshooting messages and user guidance
7. Initial authorization flow handles user consent and location selection
8. Refresh token persisted and used for automatic token renewal
9. Environment variables validated on startup with helpful error messages
10. Documentation includes OAuth setup guide with GHL marketplace app creation steps

## Tasks / Subtasks
- [ ] Setup OAuth configuration and environment (AC: 2, 9)
  - [ ] Add GHL_CLIENT_ID and GHL_CLIENT_SECRET to `.env.example`
  - [ ] Document how to obtain credentials from GHL marketplace
  - [ ] Load environment variables using dotenv in `src/index.ts`
  - [ ] Validate required env vars on startup (fail fast if missing)
  - [ ] Add helpful error messages for missing credentials
  - [ ] Document redirect URI requirements
- [ ] Implement encrypted token storage (AC: 4, 8)
  - [ ] Create `src/auth/token-store.ts` module
  - [ ] Define TokenStore interface: accessToken, refreshToken, expiresAt
  - [ ] Generate encryption key from environment (ENCRYPTION_KEY) or auto-generate
  - [ ] Implement saveTokens() with AES-256-CBC encryption
  - [ ] Implement loadTokens() with decryption
  - [ ] Save encrypted tokens to `mcp-servers/ghl-api-server/.tokens.enc`
  - [ ] Add `.tokens.enc` to .gitignore
  - [ ] Test encryption/decryption roundtrip with sample tokens
- [ ] Implement OAuth 2.0 authorization flow (AC: 1, 7)
  - [ ] Create `src/auth/oauth.ts` module
  - [ ] Define OAuthConfig interface: clientId, clientSecret, redirectUri, tokenEndpoint
  - [ ] Implement generateAuthUrl() for GHL marketplace OAuth
  - [ ] Implement exchangeCodeForToken() to get initial access token
  - [ ] Handle authorization response and extract code parameter
  - [ ] Store tokens after successful exchange
  - [ ] Log authorization success with location info
  - [ ] Handle authorization errors (user denied, invalid code, etc.)
- [ ] Implement OAuth2Manager class (AC: 3, 8)
  - [ ] Create OAuth2Manager class with tokenStore reference
  - [ ] Implement getAccessToken() method with auto-refresh logic
  - [ ] Implement isTokenExpired() check with 5-minute buffer
  - [ ] Implement refreshAccessToken() method
  - [ ] Make refresh token exchange request to GHL API
  - [ ] Update tokenStore with new tokens
  - [ ] Persist refreshed tokens to encrypted file
  - [ ] Log refresh events (success and failure)
  - [ ] Handle refresh token expiry (require re-authorization)
- [ ] Implement test_oauth MCP tool (AC: 5)
  - [ ] Create `src/tools/oauth-test.ts` module
  - [ ] Define Zod schema for test_oauth (empty object)
  - [ ] Implement handler that checks OAuth connection status
  - [ ] Return: authenticated (boolean), tokenExpiry (ISO string), locationId
  - [ ] Test token refresh if close to expiry
  - [ ] Register tool in `src/index.ts`
  - [ ] Test tool invocation manually
- [ ] Implement comprehensive error handling (AC: 6)
  - [ ] Create error types: OAuthError, TokenRefreshError, InvalidCredentialsError
  - [ ] Log all OAuth errors with timestamp and context
  - [ ] Provide user-friendly error messages for common issues
  - [ ] Handle network errors during token exchange/refresh
  - [ ] Handle invalid client credentials error
  - [ ] Handle expired refresh token (guide to re-authorize)
  - [ ] Add retry logic for transient failures (3 attempts with backoff)
- [ ] Create OAuth setup documentation (AC: 10)
  - [ ] Create `docs/guides/oauth-setup.md` guide
  - [ ] Document how to create GHL marketplace app
  - [ ] Document OAuth scopes required for API access
  - [ ] Document redirect URI configuration (http://localhost:3000/callback)
  - [ ] Provide step-by-step authorization walkthrough
  - [ ] Add troubleshooting section for common OAuth errors
  - [ ] Include screenshots of GHL marketplace OAuth settings
  - [ ] Add instructions for initial authorization vs. automatic refresh
- [ ] Integration and testing (AC: 1-9)
  - [ ] Test initial authorization flow from scratch
  - [ ] Test token storage and retrieval
  - [ ] Test automatic token refresh before expiry
  - [ ] Test test_oauth tool with valid tokens
  - [ ] Test error handling with invalid credentials
  - [ ] Test error handling with expired refresh token
  - [ ] Verify tokens are never logged in plaintext
  - [ ] Verify .tokens.enc is encrypted (not readable)

## Dev Notes

### OAuth 2.0 Flow
[Source: architecture/4-system-architecture.md]

**GHL OAuth Endpoints:**
- **Authorization URL:** `https://marketplace.gohighlevel.com/oauth/chooselocation`
- **Token Endpoint:** `https://services.leadconnectorhq.com/oauth/token`
- **Token Expiry:** 24 hours (86400 seconds)

**Authorization Flow:**
1. User visits authorization URL with client_id and redirect_uri
2. User selects GHL location and grants permissions
3. GHL redirects to redirect_uri with authorization code
4. App exchanges code for access_token and refresh_token
5. Access token used for API calls
6. Refresh token used to get new access token before expiry

**Configuration Interface:**
```typescript
interface OAuthConfig {
  clientId: string;          // from GHL_CLIENT_ID env
  clientSecret: string;      // from GHL_CLIENT_SECRET env
  redirectUri: string;       // http://localhost:3000/callback
  tokenEndpoint: string;     // GHL token URL
  authEndpoint: string;      // GHL authorization URL
}
```

### Token Management Implementation

**Token Store Interface:**
```typescript
// src/auth/token-store.ts

interface TokenStore {
  accessToken: string;
  refreshToken: string;
  expiresAt: number;         // Unix timestamp (ms)
  locationId?: string;       // GHL location ID
}

class OAuth2Manager {
  private tokenStore: TokenStore | null = null;

  async getAccessToken(): Promise<string> {
    if (!this.tokenStore) {
      throw new Error('Not authenticated. Run initial OAuth flow.');
    }

    if (this.isTokenExpired()) {
      await this.refreshAccessToken();
    }

    return this.tokenStore.accessToken;
  }

  private isTokenExpired(): boolean {
    if (!this.tokenStore) return true;

    // Refresh 5 minutes before expiry (300000ms buffer)
    const expiryBuffer = 300000;
    return Date.now() >= this.tokenStore.expiresAt - expiryBuffer;
  }

  private async refreshAccessToken(): Promise<void> {
    logger.info('Refreshing OAuth access token...');

    const response = await fetch(this.config.tokenEndpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: this.tokenStore!.refreshToken,
        client_id: this.config.clientId,
        client_secret: this.config.clientSecret
      })
    });

    if (!response.ok) {
      throw new Error(`Token refresh failed: ${response.statusText}`);
    }

    const data = await response.json();

    this.tokenStore = {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresAt: Date.now() + (data.expires_in * 1000),
      locationId: this.tokenStore.locationId
    };

    await saveTokens(this.tokenStore);
    logger.info('OAuth token refreshed successfully');
  }
}
```

### Encrypted Token Storage
[Source: architecture/8-security-architecture.md]

**Security Implementation:**
```typescript
// src/auth/token-store.ts

import crypto from 'crypto';
import fs from 'fs/promises';
import path from 'path';

const TOKEN_FILE = path.join(__dirname, '../../.tokens.enc');
const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || generateEncryptionKey();

interface EncryptedTokens {
  iv: string;
  encryptedData: string;
}

export async function saveTokens(tokens: TokenStore): Promise<void> {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(ENCRYPTION_KEY, 'hex'), iv);

  let encrypted = cipher.update(JSON.stringify(tokens), 'utf8', 'hex');
  encrypted += cipher.final('hex');

  const encryptedTokens: EncryptedTokens = {
    iv: iv.toString('hex'),
    encryptedData: encrypted
  };

  await fs.writeFile(TOKEN_FILE, JSON.stringify(encryptedTokens), 'utf8');
  logger.debug('Tokens encrypted and saved');
}

export async function loadTokens(): Promise<TokenStore | null> {
  try {
    const fileContent = await fs.readFile(TOKEN_FILE, 'utf8');
    const data: EncryptedTokens = JSON.parse(fileContent);

    const decipher = crypto.createDecipheriv(
      'aes-256-cbc',
      Buffer.from(ENCRYPTION_KEY, 'hex'),
      Buffer.from(data.iv, 'hex')
    );

    let decrypted = decipher.update(data.encryptedData, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    const tokens: TokenStore = JSON.parse(decrypted);
    logger.debug('Tokens loaded and decrypted');
    return tokens;
  } catch (error) {
    if ((error as any).code === 'ENOENT') {
      logger.info('No stored tokens found. Initial OAuth flow required.');
      return null;
    }
    throw error;
  }
}

function generateEncryptionKey(): string {
  // Generate 32-byte key for AES-256
  const key = crypto.randomBytes(32).toString('hex');
  logger.warn('Generated new encryption key. Save to ENCRYPTION_KEY env var for persistence.');
  return key;
}
```

**Security Checklist:**
- ✅ Tokens encrypted with AES-256-CBC
- ✅ Initialization vector (IV) randomized for each save
- ✅ Encryption key from environment or auto-generated
- ✅ Token file (.tokens.enc) in .gitignore
- ✅ Tokens never logged in plaintext
- ✅ HTTPS for all OAuth API calls

### test_oauth MCP Tool

**Tool Implementation:**
```typescript
// src/tools/oauth-test.ts

import { z } from 'zod';
import { oauthManager } from '../auth/oauth.js';

export const testOAuthTool = {
  name: 'test_oauth',
  description: 'Test OAuth 2.0 connection, verify authentication status, and check token expiry',
  schema: z.object({}),
  handler: async () => {
    try {
      const accessToken = await oauthManager.getAccessToken();
      const tokenStore = oauthManager.getTokenStore();

      return {
        authenticated: true,
        tokenExpiry: new Date(tokenStore.expiresAt).toISOString(),
        locationId: tokenStore.locationId || 'unknown',
        message: 'OAuth connection is active and tokens are valid'
      };
    } catch (error) {
      return {
        authenticated: false,
        error: (error as Error).message,
        message: 'OAuth authentication failed. Run initial authorization flow.'
      };
    }
  }
};
```

### Initial Authorization Flow

**Manual Authorization Process:**
1. Developer creates marketplace app in GHL
2. Developer configures OAuth redirect URI: `http://localhost:3000/callback`
3. Developer sets GHL_CLIENT_ID and GHL_CLIENT_SECRET in `.env`
4. Developer visits authorization URL (generated by helper script)
5. Developer selects location and grants permissions
6. GHL redirects with authorization code
7. Developer pastes code into CLI prompt
8. App exchanges code for tokens and stores encrypted

**Helper Script (Optional):**
```typescript
// scripts/authorize-ghl.ts
// Helper script to walk through initial OAuth flow

import { OAuth2Manager } from '../mcp-servers/ghl-api-server/src/auth/oauth.js';

async function authorize() {
  const oauth = new OAuth2Manager();

  console.log('1. Visit this URL to authorize:');
  console.log(oauth.generateAuthUrl());
  console.log('\n2. After authorizing, paste the authorization code:');

  // Read code from stdin
  const code = await readStdin();

  console.log('\n3. Exchanging code for tokens...');
  await oauth.exchangeCodeForToken(code);

  console.log('✅ Authorization successful! Tokens saved.');
}
```

### Error Handling Patterns

**Common OAuth Errors:**
```typescript
// src/auth/errors.ts

export class OAuthError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = 'OAuthError';
  }
}

export function handleOAuthError(error: any): never {
  if (error.code === 'INVALID_CLIENT') {
    logger.error('Invalid GHL_CLIENT_ID or GHL_CLIENT_SECRET');
    throw new OAuthError(
      'Invalid OAuth credentials. Check GHL_CLIENT_ID and GHL_CLIENT_SECRET in .env',
      'INVALID_CLIENT'
    );
  }

  if (error.code === 'INVALID_GRANT') {
    logger.error('Authorization code or refresh token expired');
    throw new OAuthError(
      'Authorization expired. Run initial OAuth flow again.',
      'INVALID_GRANT'
    );
  }

  if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
    logger.error('Network error during OAuth request');
    throw new OAuthError(
      'Network error. Check internet connection and try again.',
      'NETWORK_ERROR'
    );
  }

  throw error;
}
```

### Environment Variables

**.env.example:**
```bash
# GHL OAuth Credentials (from marketplace.gohighlevel.com)
GHL_CLIENT_ID=your-client-id-here
GHL_CLIENT_SECRET=your-client-secret-here

# Encryption key for token storage (32 bytes hex, auto-generated if not provided)
ENCRYPTION_KEY=64-character-hex-string-here

# Optional: Override default redirect URI
# GHL_REDIRECT_URI=http://localhost:3000/callback
```

### Testing Strategy
[Source: architecture/11-testing-strategy.md]

**Manual Testing:**
1. Test initial authorization flow from scratch
2. Verify tokens are encrypted in .tokens.enc
3. Test automatic token refresh (mock expiry or wait)
4. Test test_oauth tool with valid authentication
5. Test error handling with invalid credentials
6. Test error handling with missing .env variables
7. Verify tokens never appear in logs

**Success Criteria:**
- Initial OAuth flow completes without errors
- Tokens saved and encrypted successfully
- Token refresh happens automatically before expiry
- test_oauth tool returns authenticated=true
- Invalid credentials produce helpful error messages
- .tokens.enc file is not human-readable

### Dependencies on Other Stories

**Requires:**
- Story 3.1 (MCP Server Foundation) - Must be completed first

**Blocks:**
- Story 3.3 (Rate Limiting) - Needs OAuth for authenticated API calls
- Story 3.4 (Workflow Tools) - Needs OAuth for API operations
- Story 3.5 (Other Tools) - Needs OAuth for API operations

**Blocked By:**
- Story 3.1 (Foundation) - Required for basic server structure

### GHL OAuth Scopes

**Required Scopes for GHL Wiz:**
- `contacts.readonly` - Read contact information
- `contacts.write` - Create and update contacts
- `workflows.readonly` - Read workflow configurations
- `workflows.write` - Create and manage workflows
- `calendars.readonly` - Read calendar configurations
- `calendars.write` - Create appointments
- `locations.readonly` - Read location information

**Note:** Scopes configured in GHL marketplace app settings, not in code.

### Common Issues and Troubleshooting

**Issue: "Invalid client credentials" error**
- Solution: Verify GHL_CLIENT_ID and GHL_CLIENT_SECRET in .env match marketplace app
- Check for extra spaces or quotes in .env values

**Issue: Authorization code expired**
- Solution: Authorization codes expire quickly. Complete exchange within 60 seconds.

**Issue: Refresh token expired**
- Solution: Refresh tokens expire after ~60 days. Run initial authorization flow again.

**Issue: .tokens.enc decryption fails**
- Solution: ENCRYPTION_KEY changed or corrupted. Delete .tokens.enc and re-authorize.

**Issue: Redirect URI mismatch**
- Solution: Ensure redirect URI in code matches GHL marketplace app configuration exactly.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-25 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-10-26 | 2.0 | Enhanced to production-ready status with detailed tasks (8 task groups, 50+ subtasks), enhanced AC (10 items), comprehensive OAuth implementation patterns, security best practices, error handling, troubleshooting guide. Status changed to Ready for Development. | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_(To be filled by Dev Agent)_

### Debug Log References
_(To be filled by Dev Agent)_

### Completion Notes List
_(To be filled by Dev Agent)_

### File List
_(To be filled by Dev Agent)_

## QA Results

**Review Date:** 2025-10-26 (v2.0)
**Reviewer:** Bob (Scrum Master)
**Gate Status:** READY FOR DEVELOPMENT

### Summary
Story 3.2 has been enhanced from draft to production-ready status with comprehensive OAuth 2.0 implementation details, encrypted token storage patterns, automatic refresh logic, error handling, and complete setup documentation. Acceptance criteria expanded to 10 testable items with detailed task breakdown.

### Validation for Development
- ✅ All acceptance criteria are testable and measurable
- ✅ Tasks are specific and actionable with clear AC mapping (8 major task groups)
- ✅ OAuth 2.0 flow fully documented with GHL-specific endpoints
- ✅ Security implementation follows industry best practices (AES-256-CBC encryption)
- ✅ Token refresh logic prevents expired token errors
- ✅ Error handling covers all common OAuth failure scenarios
- ✅ test_oauth tool provides easy verification of OAuth status
- ✅ Documentation includes setup guide and troubleshooting
- ✅ Dependencies clearly identified (requires Story 3.1, blocks Stories 3.3-3.5)
- ✅ Environment variables validated with helpful error messages

**Testability Score:** 10/10

**Status Change:** Draft → Ready for Development

**Security Review:** ✅ PASSED
- Tokens encrypted at rest
- Never logged in plaintext
- HTTPS for all OAuth requests
- .tokens.enc in .gitignore
- Auto-refresh prevents token expiry
