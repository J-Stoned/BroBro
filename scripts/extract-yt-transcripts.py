#!/usr/bin/env python3
"""
BroBro - YouTube Transcript Extraction Script
Extracts transcripts from configured YouTube sources for knowledge base
"""

import os
import sys
import json
import time
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional
import scrapetube
from youtube_transcript_api import YouTubeTranscriptApi
from youtube_transcript_api._errors import TranscriptsDisabled, NoTranscriptFound

# Configuration
PROJECT_ROOT = Path(__file__).parent.parent
CONFIG_FILE = PROJECT_ROOT / "kb" / "youtube-sources.json"
OUTPUT_DIR = PROJECT_ROOT / "kb" / "youtube-transcripts"
RATE_LIMIT_DELAY = 1.0  # Seconds between requests


class YouTubeExtractor:
    """Extract transcripts from YouTube videos"""

    def __init__(self, config_path: str):
        self.config_path = config_path
        self.config = self.load_config()
        self.stats = {
            "total_videos_processed": 0,
            "successful_extractions": 0,
            "failed_extractions": 0,
            "skipped_videos": 0,
            "total_creators": 0,
            "total_specific_videos": 0,
            "extraction_errors": []
        }
        self.index_data = []

    def load_config(self) -> Dict:
        """Load YouTube sources configuration"""
        with open(self.config_path, 'r', encoding='utf-8') as f:
            return json.load(f)

    def get_channel_videos(self, channel_id: str, max_videos: int = 25) -> List[Dict]:
        """
        Get list of videos from a YouTube channel

        Args:
            channel_id: YouTube channel ID (e.g., @channelhandle)
            max_videos: Maximum number of videos to retrieve

        Returns:
            List of video dictionaries with metadata
        """
        print(f"  Fetching videos from {channel_id}...")

        try:
            videos = []
            # Use scrapetube to get channel videos
            channel_videos = scrapetube.get_channel(channel_username=channel_id.replace('@', ''))

            for video in channel_videos:
                if len(videos) >= max_videos:
                    break

                video_id = video['videoId']
                title = video.get('title', {}).get('runs', [{}])[0].get('text', 'Unknown')

                # Get publish date if available
                published_text = video.get('publishedTimeText', {}).get('simpleText', '')

                videos.append({
                    'videoId': video_id,
                    'title': title,
                    'url': f'https://www.youtube.com/watch?v={video_id}',
                    'published': published_text
                })

            print(f"  Found {len(videos)} videos")
            return videos

        except Exception as e:
            print(f"  Error fetching videos: {e}")
            self.stats['extraction_errors'].append({
                'channel': channel_id,
                'error': str(e)
            })
            return []

    def extract_transcript(self, video_id: str, languages: List[str] = ['en']) -> Optional[str]:
        """
        Extract transcript from a YouTube video

        Args:
            video_id: YouTube video ID
            languages: List of preferred languages

        Returns:
            Transcript text or None if extraction failed
        """
        try:
            # Get transcript directly
            transcript_data = YouTubeTranscriptApi.get_transcript(video_id, languages=languages)

            # Combine text
            if self.config['extractionSettings']['includeTimestamps']:
                text = '\n'.join([f"[{entry['start']:.2f}s] {entry['text']}" for entry in transcript_data])
            else:
                text = ' '.join([entry['text'] for entry in transcript_data])

            return text

        except (TranscriptsDisabled, NoTranscriptFound) as e:
            # Try auto-generated if allowed
            if self.config['extractionSettings']['includeAutoGeneratedTranscripts']:
                try:
                    transcript_data = YouTubeTranscriptApi.get_transcript(video_id)
                    if self.config['extractionSettings']['includeTimestamps']:
                        text = '\n'.join([f"[{entry['start']:.2f}s] {entry['text']}" for entry in transcript_data])
                    else:
                        text = ' '.join([entry['text'] for entry in transcript_data])
                    return text
                except:
                    return None
            return None
        except Exception as e:
            # Silently skip errors
            return None

    def save_transcript(self, video_id: str, title: str, transcript: str,
                       creator: str, topics: List[str], metadata: Dict):
        """Save transcript to file with metadata"""

        # Sanitize filename
        safe_title = "".join(c for c in title if c.isalnum() or c in (' ', '-', '_')).rstrip()
        safe_title = safe_title[:100]  # Limit length

        # Save by creator
        creator_dir = OUTPUT_DIR / "by-creator" / creator.lower().replace(' ', '-')
        creator_dir.mkdir(parents=True, exist_ok=True)

        creator_file = creator_dir / f"{video_id}_{safe_title}.txt"
        with open(creator_file, 'w', encoding='utf-8') as f:
            f.write(f"Title: {title}\n")
            f.write(f"Video ID: {video_id}\n")
            f.write(f"Creator: {creator}\n")
            f.write(f"URL: https://www.youtube.com/watch?v={video_id}\n")
            f.write(f"Topics: {', '.join(topics)}\n")
            f.write(f"\n{'='*80}\n\n")
            f.write(transcript)

        # Save by topic
        if self.config['outputSettings']['saveByTopic']:
            for topic in topics:
                topic_dir = OUTPUT_DIR / "by-topic" / topic
                topic_dir.mkdir(parents=True, exist_ok=True)

                topic_file = topic_dir / f"{video_id}_{safe_title}.txt"
                # Create symlink or copy
                try:
                    with open(topic_file, 'w', encoding='utf-8') as f:
                        f.write(f"Title: {title}\n")
                        f.write(f"Video ID: {video_id}\n")
                        f.write(f"Creator: {creator}\n")
                        f.write(f"URL: https://www.youtube.com/watch?v={video_id}\n")
                        f.write(f"Topic: {topic}\n")
                        f.write(f"\n{'='*80}\n\n")
                        f.write(transcript)
                except:
                    pass

        # Add to index
        self.index_data.append({
            **metadata,
            'filepath_creator': str(creator_file.relative_to(PROJECT_ROOT)),
            'word_count': len(transcript.split()),
            'char_count': len(transcript)
        })

    def process_creator(self, creator: Dict):
        """Process all videos from a creator"""
        if not creator.get('enabled', False):
            print(f"Skipping {creator['name']} (disabled)")
            return

        print(f"\nProcessing Creator: {creator['name']}")
        print(f"  Channel: {creator['channelId']}")
        print(f"  Max Videos: {creator['maxVideos']}")

        # Get videos from channel
        videos = self.get_channel_videos(creator['channelId'], creator['maxVideos'])

        for i, video in enumerate(videos, 1):
            print(f"  [{i}/{len(videos)}] {video['title'][:60]}...")

            video_id = video['videoId']

            # Extract transcript
            transcript = self.extract_transcript(video_id)

            if transcript:
                # Save transcript
                metadata = {
                    'videoId': video_id,
                    'title': video['title'],
                    'creator': creator['name'],
                    'channelId': creator['channelId'],
                    'url': video['url'],
                    'topics': creator['topics'],
                    'priority': creator['priority'],
                    'extractedDate': datetime.now().isoformat()
                }

                self.save_transcript(
                    video_id=video_id,
                    title=video['title'],
                    transcript=transcript,
                    creator=creator['name'],
                    topics=creator['topics'],
                    metadata=metadata
                )

                self.stats['successful_extractions'] += 1
                print(f"    ✓ Transcript extracted ({len(transcript)} chars)")
            else:
                self.stats['failed_extractions'] += 1
                print(f"    ✗ No transcript available")

            self.stats['total_videos_processed'] += 1

            # Rate limiting
            time.sleep(RATE_LIMIT_DELAY)

    def process_specific_video(self, video_config: Dict):
        """Process a specific video"""
        if not video_config.get('enabled', False):
            return

        # Extract video ID from URL
        url = video_config['url']
        if 'v=' in url:
            video_id = url.split('v=')[1].split('&')[0]
        else:
            print(f"  ✗ Invalid URL format: {url}")
            return

        print(f"\nProcessing Specific Video: {video_config.get('title', video_id)}")
        print(f"  URL: {url}")

        # Extract transcript
        transcript = self.extract_transcript(video_id)

        if transcript:
            # Save to specific directory
            specific_dir = OUTPUT_DIR / "specific"
            specific_dir.mkdir(parents=True, exist_ok=True)

            safe_title = "".join(c for c in video_config.get('title', video_id) if c.isalnum() or c in (' ', '-', '_')).rstrip()

            specific_file = specific_dir / f"{video_id}_{safe_title}.txt"
            with open(specific_file, 'w', encoding='utf-8') as f:
                f.write(f"Title: {video_config.get('title', 'Unknown')}\n")
                f.write(f"Video ID: {video_id}\n")
                f.write(f"Creator: {video_config.get('creator', 'Unknown')}\n")
                f.write(f"URL: {url}\n")
                f.write(f"Category: {video_config.get('category', 'general')}\n")
                f.write(f"Topics: {', '.join(video_config.get('topics', []))}\n")
                f.write(f"\n{'='*80}\n\n")
                f.write(transcript)

            # Add to index
            metadata = {
                'videoId': video_id,
                'title': video_config.get('title', 'Unknown'),
                'creator': video_config.get('creator', 'Unknown'),
                'url': url,
                'category': video_config.get('category', 'general'),
                'topics': video_config.get('topics', []),
                'priority': video_config.get('priority', 'medium'),
                'extractedDate': datetime.now().isoformat(),
                'filepath_specific': str(specific_file.relative_to(PROJECT_ROOT)),
                'word_count': len(transcript.split()),
                'char_count': len(transcript)
            }

            self.index_data.append(metadata)

            self.stats['successful_extractions'] += 1
            print(f"  ✓ Transcript extracted ({len(transcript)} chars)")
        else:
            self.stats['failed_extractions'] += 1
            print(f"  ✗ No transcript available")

        self.stats['total_videos_processed'] += 1

    def save_index(self):
        """Save index.json with all transcript metadata"""
        index_file = OUTPUT_DIR / "index.json"

        index_output = {
            'totalTranscripts': len(self.index_data),
            'extractionDate': datetime.now().isoformat(),
            'stats': self.stats,
            'transcripts': self.index_data
        }

        with open(index_file, 'w', encoding='utf-8') as f:
            json.dump(index_output, f, indent=2, ensure_ascii=False)

        print(f"\n✓ Index saved: {index_file}")

    def run(self):
        """Main extraction process"""
        print("="*80)
        print("BroBro - YouTube Transcript Extraction")
        print("="*80)
        print(f"Config: {self.config_path}")
        print(f"Output: {OUTPUT_DIR}")
        print()

        # Process creators
        creators = [c for c in self.config.get('creators', []) if c.get('enabled', False)]
        self.stats['total_creators'] = len(creators)

        print(f"Enabled Creators: {len(creators)}")
        for creator in creators:
            try:
                self.process_creator(creator)
            except Exception as e:
                print(f"  Error processing {creator['name']}: {e}")
                self.stats['extraction_errors'].append({
                    'creator': creator['name'],
                    'error': str(e)
                })

        # Process specific videos
        specific_videos = [v for v in self.config.get('specificVideos', []) if v.get('enabled', False)]
        self.stats['total_specific_videos'] = len(specific_videos)

        print(f"\nEnabled Specific Videos: {len(specific_videos)}")
        for video in specific_videos:
            try:
                self.process_specific_video(video)
            except Exception as e:
                print(f"  Error processing {video.get('url', 'unknown')}: {e}")
                self.stats['extraction_errors'].append({
                    'video': video.get('url', 'unknown'),
                    'error': str(e)
                })

        # Save index
        if self.index_data:
            self.save_index()

        # Print summary
        print("\n" + "="*80)
        print("EXTRACTION COMPLETE")
        print("="*80)
        print(f"Total Videos Processed: {self.stats['total_videos_processed']}")
        print(f"Successful Extractions: {self.stats['successful_extractions']}")
        print(f"Failed Extractions: {self.stats['failed_extractions']}")
        print(f"Total Transcripts: {len(self.index_data)}")
        print(f"Output Directory: {OUTPUT_DIR}")

        if self.stats['extraction_errors']:
            print(f"\nErrors: {len(self.stats['extraction_errors'])}")
            for error in self.stats['extraction_errors'][:5]:  # Show first 5
                print(f"  - {error}")


def main():
    """Main entry point"""
    import sys

    # Set UTF-8 encoding for Windows
    if sys.platform == 'win32':
        import io
        sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
        sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')

    # Run extraction
    extractor = YouTubeExtractor(str(CONFIG_FILE))
    extractor.run()


if __name__ == "__main__":
    main()
